\documentclass[a4paper,12pt]{book}
\usepackage{amsmath,  amsthm,enumerate}
\usepackage{csquotes}
\usepackage[provide=*,french]{babel}
\usepackage[dvipsnames]{xcolor}
\usepackage{quiver, tikz}

%symbole caligraphique
\usepackage{mathrsfs}

%hyperliens
\usepackage{hyperref}

%pseudo-code
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage{fancyhdr}

\pagestyle{fancy}
\addtolength{\headwidth}{\marginparsep}
\addtolength{\headwidth}{\marginparwidth}
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}
\fancyhf{}
\fancyfoot[C]{\thepage}
\fancyhead[LO]{\textit \leftmark}
\fancyhead[RE]{\textit \rightmark}
\renewcommand{\headrulewidth}{0pt} % and the line
\fancypagestyle{plain}{%
    \fancyhead{} % get rid of headers
}

%bibliographie
\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}

\addbibresource{bib.bib}

\usepackage{appendix}
\renewcommand{\appendixpagename}{Annexe}

\definecolor{wgrey}{RGB}{148, 38, 55}

\setlength\parindent{24pt}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\rel}{\omathcal{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\A}{\mathbb{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\Or}{\mathcal{O}}
\newcommand{\F}{\mathbb F}
\newcommand{\Hom}{\textrm{Hom}}
\newcommand{\disc}{\textrm{disc}}
\newcommand{\Pic}{\textrm{Pic}}
\newcommand{\End}{\textrm{End}}
\newcommand{\Spec}{\textrm{Spec}}

\newcommand{\cL}{\mathscr{L}}
\newcommand{\G}{\mathscr{G}}
\newcommand{\D}{\mathscr{D}}
\newcommand{\E}{\mathscr{E}}
\renewcommand{\H}{\mathscr{H}}

\theoremstyle{plain}
\newtheorem{thm}[subsection]{Théoreme}
\newtheorem{lem}[subsection]{Lemme}
\newtheorem{prop}[subsection]{Proposition}
\newtheorem{cor}[subsection]{Corollaire}
\newtheorem{heur}{Heuristique}
\newtheorem{rem}{Remarque}
\newtheorem{note}{Note}

\theoremstyle{definition}
\newtheorem{conj}{Conjecture}
\newtheorem{prob}{Problème}
\newtheorem{quest}{Question}
\newtheorem{prot}{Protocole}
\newtheorem{algo}{Algorithme}
\newtheorem{defn}[subsection]{Définition}
\newtheorem{exmp}[subsection]{Exemples}
\newtheorem{exo}[subsection]{Exercices}
\newtheorem{ex}[subsection]{Exemple}
\newtheorem{exs}[subsection]{Exemples}

\theoremstyle{remark}

\definecolor{wgrey}{RGB}{148, 38, 55}
\definecolor{wgreen}{RGB}{100, 200,0} 
\hypersetup{
    colorlinks=true,
    linkcolor=wgreen,
    urlcolor=wgrey,
    filecolor=wgrey
}

\title{Théorie des nombres algorithmique\\ \small{(Aspects classiques)}}
\date{2023-2024}

\begin{document}
\maketitle
\tableofcontents
\chapter*{Introduction}

Le cours discute l'algorithmique quantique et le but c'est l'algo de 
Shor \cite{Shor_1997}!

\chapter{Formalisme}
\section{Automates finis et langages}
Un alphabet est un ensemble de symboles, on regarde en général $\Sigma=
\{0,1\}$ les binaires. Ensuite y'a le langage élémentaire :
\[\{\emptyset, \in, 0, 1\}\]
À partir du langage élémentaire on construit les langages régulier,
par concaténations et unions finies.

\begin{defn}[Langage]
    On prends comme convention que les sous ensembles 
    \[L\subset\Sigma^*\]
    où $\Sigma = \{0,1\}$.
\end{defn}

Pour les automates on prends des $5$-tuples $(Q,\Sigma,\delta, q_0, F)$
où $Q$ est un ensemble d'états $\Sigma$ l'alphabet, 
\[\delta\colon Q\times \Sigma \to Q\]
une fonction de transition, $q_0$ l'état initial et $F$ l'ensemble des
états acceptés/terminaux. On étant ensuite $\delta$ en 
    \[\delta^*\colon Q\times \Sigma^*\to Q\]
    par $\delta^*(q, w)=\delta^*(\delta(q, w_n),w_0\ldots w_{n-1}$ avec
    $w_=w_0\ldots w_n$.
Le truc fun c'est qu'on peut déf le langage accepté par l'automate par :
\[L_{\delta}=\{w\in \Sigma^*| \delta^*(q_0,w)\in F\}.\]



\section{Machines de Turing}
En gros c'est un automate fini plus une tape infinie à droite et une
tête de lecture qui écrit et efface sur la tape.

\begin{defn}[Machine de Turing]
    Une machine de Turing est un tuple $(\Sigma, K, S,s)$
    avec $S\colon K\times \Sigma\to (\K\cup\{Y, N, H\}\times \Sigma \times \{\bullet,\leftarrow,\rightarrow\}$
    où on a les états... Un langage $L\subset \Sigma^*$ est accepté par $M$
    ssi $w\in L\leftrightarrow$ la machine s'arrête sur $Y$.
\end{defn}
\begin{defn}[Langage décidable]
    Un langage est décidable si il existe une machine de Turing qui 
    l'accepte.
\end{defn}
\begin{defn}[Fonction récursive]
    Fonction qui est calculable par une machine de Turing.
\end{defn}
Étant donné une fonction $f\colon \N\to \N$.
\begin{defn}
    On dit qu'une machine de Turing a complexité $O(f)$ si elle termine
    en temps $f(|n|)$ pour une entrée $n$ de taille $|n|$.
\end{defn}
\begin{defn}[PTIME]
    Dans l'ensemble des langages $2^{\Sigma^*}$ on regarde PTIME
    l'ensemble des langages décidables de complexité polynomial.
\end{defn}
\begin{defn}[FPTIME]
    Dans l'ensemble des fonctions $(\Sigma^*)^{\Sigma^*}$
    on déf $FPTIME$ l'analogue pour les fonctions.
\end{defn}

\section{Exponentiation rapide}
\begin{algorithm}
    \caption{Calcul de $a^e\mod N$}
\begin{algorithmic}[1]
    \State Écrire $e=\sum e_i 2^i$.
    \State Calculer et enregistrer $a^{2^i}\mod N$ en réduisant à
    chaque carré par $N$ pour les $e_i\ne 0$.
    \State Multiplier  $\prod_i a^{2^i}=a^e\mod N$.
\end{algorithmic}
\end{algorithm}

\chapter{Arithmétique et modules}
\begin{thm}
    Soit $r\leq 1$ et $M\leq \Z^r$ alors il existe $a_1,\ldots,a_s$ avec 
    $0\leq s\leq r$ et une base $v_1,\ldots, v_r$ de $\Z^r$ telle que 
    $a_1\mid\ldots\mid a_s$ et \[M=\bigoplus_i^s a_i v_i\]
\end{thm}

Grâce à lui on peut résoudre un système linéaire $AX=0$ en calculant
une base de $\ker(A)$.

\begin{thm}
    Soit $G$ un groupe abélien de type fini. Alors il existe
    $a_1\mid\ldots\mid a_s$ t.q \[G\simeq \Z^r\oplus \bigoplus_{i=1}^r
    (\Z/a_i\Z)\] et la décomposition est unique.
\end{thm}

\section{Miller-Rabin}
Un nombre $n\geq 2$ est pseudo-premier si 
$a^{n-1}\equiv 1\mod n$ pour tout $a\in (\Z/n\Z)^{\times}$.
On peut détecter si $n$ est composé par contre.

\begin{thm}
    Si $n$ est impair premier, alors $n-1=2^k.m$
    et pour tout $a\in(\Z/n\Z)^{\times}$ alors 
    $a^{m}=1$ ou $a^{m2^c}=-1$ pour un $c\leq k$.
\end{thm}

\begin{thm}
    Si $n\geq 15$ est composé et impair alors
    MR(n,a) est faux pour plus de $\varphi(n)/4$
    éléments de $(\Z/n\Z)^{\times}$.
\end{thm}

\section{Distributions}
Si $X\colon\Omega\to G$ une variable aléatoire de loi uniforme.
Et $Y$ une loi quelconque, alors $Z=X.Y$ suis une loi uniforme!

\section{Densité de premiers}
Soit $A\subset \R$ alors 
\[\pi(A)=\#\{n|1\leq n\leq A,~n\textrm{ est premier}\}\]
a un équivalent 
\[\pi(A)=\frac{A}{ln(A)}(1+o(1))\]
C'est Hadamard, de la vallée Poussin (1900).

\section{Racines carrées dans $\F_p^{\times}$}
On note $p-1=2*q$ si $(a,p)=1$ et $a^q=1$. On regarde le cas où 
$p\equiv 3\mod 4$. Si on note $l\equiv 2^{-1} \mod q$ alors on écrit
$q=2l-1$. Soit $S$ les carrés de $\F_p^{\times}$, $S$ est cyclique 
de taille $q$ impaire. Alors $[2]\colon S\to S$ est une bijection
d'inverse $[l]\colon S\to S$ (là $[n]$ c'est $[n].g=g^n$). Alors, 
on a $r\equiv a^l\mod p$ avec $l=\frac{q+1}{2}$ et $r^2=a\mod p$.
\section{Carrés dans $(\Z/n\Z)^{\times}$}
On note $n=\prod_i p_i^{e_i}$. Par le théorème chinois, $x\mod n$ est
un carré ssi $\forall i$ $x\mod p_i^{e_i}$ est un carré. 

Les cas particuliers $n=pq$ et $n=p^2q$ sont les cas RSA, et trouver
une racine carrées implique de factoriser $n$ avec notre méthode. En
fait à l'inverse si on peut calculer des racines carrées, on peut 
factoriser.

\printbibliography

\end{document}

